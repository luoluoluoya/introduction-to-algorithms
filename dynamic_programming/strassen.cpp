//
// Created by 张锐 on 2020/12/10.
//

/*
#### 矩阵链乘法

* 给定一个n个矩阵的序列(矩阵链) $〈A_1, A_2,…，A_n,〉$，我们希望计算它们的乘积 $A_1A_2..A_n$

* 为了计算表达式,我们可以先用括号明确计算次序，然后利用标准的矩阵相乘算法进行计算。由于矩阵乘法满足结合律，因此任何加括号的方法都会得到相同的计算结果。我们称有如下性质的矩阵乘积链为**完全括号化的(fully parenthesized)**：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。对矩阵链加括号的方式会对乘积运算的代价产生巨大影响。

* 两个矩阵相乘

  ```
  MATRIX-MULTIPLY(A, B)
  	if A.columns != B.rows
  		error 'xx'
    else
    	let c be a new A.rows * B.columns matrix
    	for i = 1 to A.rows
    		for j = 1 to B.columns
    			c_ij = 0
    			for k = 1 to A.columns
    				c_ij = c_ij + A_ik*B_kj
    return c
  ```

* 两个矩阵A和B只有相容(compatible),即A的列数等于B的行数时，才能相乘。如果A 是p*q的矩阵，B是q*r的矩阵，那么乘积C是p*r的矩阵。计算C所需时间即pqr.

* 矩阵链乘法问题(matrix-chain multiplication problem)可描述如下：给定 n 个矩阵的链 $〈A_1, A_2,…，A_n,〉$，矩阵$A_i$的规模为$p_{i-1} * p_i (1 \le i \le n)$,求完全括号化方案，使得计算乘积$A_1A_2..A_n$, 所需标量乘法次数最少。

* 注意，求解矩阵链乘法问题并不是要真正进行矩阵相乘运算，我们的目标只是确定代价最低的计算顺序。确定最优计算顺序所花费的时间通常要比随后真正进行矩阵相乘所节省的时间要少。

* **计算括号化方案的数量**  在用动态规划方法求解矩阵链乘法问题之前，我们先来说服自己——穷举所有可能的括号化方案不会产生一个高效的算法。对一个n个矩阵的链，令P(n) 表示可供选择的括号化方案的数量。当n=1时，由于只有一个矩阵，因此只有一种完全括号化方案。当 $n \ge 2$ 时，完全括号化的矩阵乘积可描述为两个完全括号化的部分积相乘的形式，而两个部分积的划分点在第k个矩阵和第 k + 1 个矩阵之间，K为中 $1, 2, ...n-1 $ 的任意一个值。因此，我们可以得到如下递归 公式：
  $$
  P(n) = \begin{cases}
  1, n = 1\\
  \sum_{k=1}^{n-1} {P(k)P(n-k)}, n \ge 2
  \end{cases}
  $$

  * 括号化方案的数量与 n 呈指数关系，通过暴力搜索穷尽所有可能的括号化方案来寻找最优方案，是 一个糟糕的策略。

* 应用动态规划方法

  * 优括号化方案的结构特征

    * 动态规划方法的第一步是寻找最优子结构，然后就可以利用这种子结构从子问题的最优解构造出原问题的最优解。在矩阵链乘法问题中，此步骤的做法如下所述。为方便起见，我们用符 表示A八乘积的结果矩阵。可以看出，如果问题是非平凡的，即那么 为了对AiAi+1-A>进行括号化，我们就必须在某个A.和之间将矩阵链划分开**3为** 间的整数）•也就是说，对某个整数奴我们首先计算矩阵A提和然后再计算它们的乘积 得到最终结果此方案的计算代价等于矩阵A“，的计算代价，加上矩阵A+l.,的计算代价， 再加上两者相乘的计算代价。

    下面我们给出本问题的最优子结构。假设A4+…孔的最优括号化方案的分割点在A.和 A.*之间。那么，继续对“前缀”子进行括号化时，我们应该直接采用独立求解它 时所得的最优方案。这样做的原因是什么呢？如果不采用独立求解所得的最优方案 来对它进行括号化，那么可以将此最优解代入厶人土…凡的最优解中，代替原来对子链 A,Ai+.-At进行括号化的方案（比財中•••&最优解的代价更高），显然，这样得到的解比 A,A*「“a原来的“最优解”代价更低：产生矛盾。对子链AiiA+z-A，我们有相似的结论： 在原问题山•••&的最优括号化方案中，对子链&+|&+2・“孔进行括号化的方法，就是它自 身的最优括号化方案.

    现在我们展示如何利用最优子结构性质从子问题的最优解构造原问题的最优解。我们已经 看到，一个非平凡的矩阵链乘法问题实例的任何解都需要划分链，而任何最优解都是由子问题 实例的最优解构成的。因此，为了构造一个矩阵链乘法问题实例的最优解，我们可以将问题划分 为两个子问题**（.AA^-A,**和AfA*+z・“A,的最优括号化问题），求出子问题实例的最优解，然 后将子问题的最优解组合起来。我们必须保证在确定分割点时，已经考察了所有可能的划分点， [373]这样就可以保证不会遗漏最优解。

  *  —个递归求解方案

    下面用子问题的最优解来递归地定义原问题最优解的代价。对矩阵链乘法问题，我们可以 将对所有确定的最小代价括号化方案作为子问题。令月表示计算 矩阵A,.,所需标量乘法次数的最小值，那么，原问题的最优解——计算4..,所需的最低代价就 是**n\.**

    我们可以递归定义刃如下。对于时的平凡冋题，矩阵链只包含唯一的矩阵Ai.,= A“因此不需要做任何标量乘法运算。所以，对所有£=1, 2,…，**n,** £]=0.**若****i*我 们利用步骤1中得到的最优子结构来计算巾日，月。我们假设的最优括号化方案的分 割点在矩阵A*和&+1之间，其中**KYK**那么，月就等于计算A；,和&+L ,的代价加上 两者相乘的代价的最小值。由于矩阵A的大小为0tXA，易知与A+..,相乘的代价为At **p****k****p,**次标量乘法运算。因此，我们得到

    = mG，妇+ m 住+1,刃+ A_i/>仇

    此递归公式假定最优分割点月是已知的，但实际上我们是不知道的。不过，&只有，一£种可 能的取值，即**k=i, i+1,** j-1.由于最优分割点必在其中，我们只需检査所有可能情况， 找到最优者即可。因此，AiAi+1-A>最小代价括号化方案的递归求解公式变为：

    「.1=(°	如果'=顶	(15.7)

    **1**	**'**	**+** **n^k** + 1 **+** **p^ptpj｝**如果 **i<.j**

    mCi,刃的值给出了子问羸最优解的代价，但它并未提供足够的信息来构造最优解。为此， 我们用sG，刃保存AA+lA,最优括号化方案的分割点位置如即使得m[i,	妇+

    m住+1, **jl+pi-iptp]**成立的冷值。

  * 计算最优代价

    现在，我们可以很容易地基于递归公式(15.7)写出一个递归算法，来计算AAz-A”相乘的 最小代价mEl,归。像我们在钢条切割问题一节中所看到的，以及即将在15. 3节中看到的那样， 此递归算法是指数时间的，并不比检査所有括号化方案的暴力搜索方法更好。	[374]

    注意到，我们需要求解的不同子问题的数目是相对较少的：每对满足的i和项 对应一个唯一的子问题，共有(2)+n=0(n2)个。递归算法会在递归调用树的不同分支中多次 遇到同一个子问题。这种子问题重叠的性质是应用动态规划的另一个标识(第一个标识是最优 子结构)。

    我们采用自底向上表格法代替基于公式(15.7)的递归算法来计算最优代价(我们将在15. 3节 中给出对应的带备忘的自顶向下方法)。下面给出的过程MATRIX-CHAIN-ORDER实现了自底 向上表格法。此过程假定矩阵A,的规模**为们_\*«=\,** 2,…，n).它的输入是一个序列 Z>=3°, **P\,**…，仅〉，其长度**为****p. length=n+l°**过程用一个辅助表1.. 来保存代 价**jj,**用另一个辅助表5[l..n-l, **2.. nJ**记录最优值刃对应的分割点上我们就可以 利用表s构造最优解。

    为了实现自底向上方法，我们必须确定计算**m[i,**刃时需要访问哪些其他表项。公式(15.7) 显示，，一£+1个矩阵链相乘的最优计算代价**m[i,**刃只依赖于那些少于，一7+1个矩阵链相乘的 最优计算代价。也就是说，对**k=i,** i+l,…，**j-1,**矩阵A,.,是**k-i+l*1个矩阵的 积，矩阵Aii..,是j-**k*个矩阵的积。因此，算法应该按长度递増的顺序求解矩阵链括 号化问题，并按对应的顺序填写表对矩阵链^.+1 -A,最优括号化的子问题，我们认为其 规模为链的长度；

  * 构造最优解

    虽然MATRIX9HAINORDER求出了计算矩阵链乘积所需的最少标量乘法运算次数，但它 并未直接指出如何进行这种最优代价的矩阵链乘法计算。表s[L.”一l，2..n]记录了构造最优解 所需的信息。每个表项s[£，刃记录了一个月值，指出的最优括号化方案的分割点应 在A.和A*之间。因此，我们知道4..,的最优计算方案中最后一次矩阵乘法运算应该是 AisAqM+L.*.我们可以用相同的方法递归地求出更早的矩阵乘法的具体计算过程，因为 s[l, s[l, W指出了计算A..".)时应进行的最后一次矩阵乘法运算；sDCl, *] + 1,招指出了 计算AgM+L.,时应进行的最后一次矩阵乘法运算。下面给出的递归过程可以输出〈A" 4+1，…， A,>的最优括号化方案，其输入为MATRIX~CHAIN-ORDER得到的表s及下标，和项。调用 PRINT-OPTIMAL-PARENS(s, 1, ”)即可输出〈&, A2,…，A”〉的最优括号化方案。

 */