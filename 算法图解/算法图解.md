* 算法是一组完成任务的指令。

* 二分查找算法
* 应选择效率最高的算法，以最大限度地减少运行时间或占用空间。

* 大O表示法是一种特殊的表示法，指出了算法的速度有多快。算法的运行时间以不同的速度增加
* 大O表示法让你能够比较操作数，它指出了算法运行时间的增速。大 O 表示法指出了最糟情况下的运行时间
  * *O*(log *n*)，也叫对数时间，这样的算法包括二分查找。
  * *O*(*n*)，也叫线性时间，这样的算法包括简单查找。
  * *O*(*n* * log *n*)，这样的算法包括将介绍的快速排序——一种速度较快的排序算法。
  * *O*($n^2$)，这样的算法包括将介绍的选择排序——一种速度较慢的排序算法。
  * *O*(*n*!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

* 算法的速度指的并非时间，而是操作数的增速。
* 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
* *O*(log *n*)比*O*(*n*)快，当需要搜索的元素越多时，前者比后者快得越多。
* 旅行商问题

---

* 计算机就像是很多抽屉的集合体，每个抽屉都有地址。

* 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址
* 数组在内存中连续存储一系列元素

* 在数组中添加新元素可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是**预留座位**：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，
  * 额外请求的位置可能根本用不上，这将浪费内存
  * 待办事项超过10个后，你还得转移

* 链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。
* 链表犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。

* 链表的优势在插入元素方面，数组的优势在于访问
* 链表存在类似的问题。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。数组与此不同：你知道其中每个元素的地址。
* 数组的元素带编号，编号从0而不是1开始。元素的位置称为索引。
* 链表仅当能够立即访问要删除的元素时，删除操作的运行时间才为*O*(1)
* 有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。

* 选择排序
* 蛮力排序算法
* 在同一个数组中，所有元素的类型都必须相同

---

* 递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。

* 如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解
* 由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环

* 编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。

* 计算机在内部使用被称为调用栈的栈。

  * 函数调用时，计算机将首先为该函数调用分配一块内存，设置变量的值... 这需要存储到内存中。
  * 每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。
  * 计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。当函数调用返回时，此时，栈顶的内存块被弹出。

  * 调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。执行完被调函数后，你回到调用函数，并从离开的地方开始接着往下执行。

* 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。
  * 重新编写代码，转而使用循环
  * 使用尾递归

* 栈有两种操作：压入和弹出。所有函数调用都进入调用栈

---

* D&C解决问题的过程包括两个步骤。
  1. 找出基线条件，这种条件必须尽可能简单。
  2. 不断将问题分解（或者说缩小规模），直到符合基线条件。 （子问题应当除了问题规模之外具有和原问题相同的性质）
* 根据 D&C 的定义，每次递归调用都必须缩小问题的规模。

* 适用于这小块地的最大方块，也是适用于整块地的最大方块（分土地问题）
* 递归保存了未完成的函数的调用状态
* 快速排序
  * 从数组中选择一个元素，这个元素被称为基准值（pivot）
  * 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。这被称为分区（partitioning）。
    * 一个由所有小于基准值的数字组成的子数组；
    * 基准值；
    * 一个由所有大于基准值的数组组成的子数组。
  * 对这两个子数组进行快速排序。
* 快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。
* 合并排序

---

* 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。
* 散列函数“将输入映射到数字”
* 实散列函数必须满足一些要求。
  * 它必须是一致的
  * 散列函数总是将同样的输入映射到相同的索引。
  * 散列函数将不同的输入映射到不同的索引。
  * 散列函数知道数组有多大，只返回有效的索引。
* 数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。
* 散列表也被称为散列映射、映射、字典和关联数组。

* 散列表由键和值组成。
* 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！

* 散列表
  * 创建映射
  * 查找
* DNS解析数据结构
* 将散列表用作缓存
* 散列表适合用于：模拟映射关系，防止重复，缓存/记住数据，以免服务器再通过处理来生成它们。
* 冲突（collision）：给两个键分配的位置相同
  * 如果两个键映射到了同一个位置，就在这个位置存储一个链表。
  * 较低的填装因子： 被占用的位置数/总位置数；
  * 良好的散列函数
* 填装因子度量的是散列表中有多少位置是空的。填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度。填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。
* 良好的散列函数让数组中的值呈均匀分布。糟糕的散列函数让值扎堆，导致大量的冲突。散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。
* 从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。

---

* 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词
* 广度优先搜索
  * 第一类问题：从节点A出发，有前往节点B的路径吗？
  * 第二类问题：从节点A出发，前往节点B的哪条路径最短？
* 最短路径问题
* 图模拟一组连接。图由节点（node）和边（edge）组成。图用于模拟不同的东西是如何相连的。
* 一个节点可能与众多节点直接相连，这些节点被称为邻居。
* 队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队。果你将两个元素加入队列，先加入的元素将在后加入的元素之前出队。队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。
* 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。

* 对于检查过的人，务必不要再去检查，否则可能导致无限循环。

---

* 狄克斯特拉算法包含4个步骤
  * 找出“最便宜”的节点，即可在最短时间内到达的节点
  * 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
  * 重复这个过程，直到对图中的每个节点都这样做了
  * 计算最终路径
* 使用广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。
* 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。
* 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。
* 要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。
* 绕环的路径不可能是最短的路径
* 狄克斯特拉算法只适用于有向无环图,仅当权重为正时狄克斯特拉算法才管用。
* 如果图中包含负权边，请使用贝尔曼-福德算法。

---

* 贪婪算法很简单：每步都采取最优的做法。每步都选择局部最优解，最终得到的就是全局最优解。
* 背包问题
* 集合覆盖问题
* 近似算法：速度有多快；得到的近似解与最优解的接近程度。

---

* 动态规划先解决子问题，再逐步解决大问题。
  * 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。
  * 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。要设计出动态规划解决方案可能很难
  * 每种动态规划解决方案都涉及网格
  * 单元格中的值通常就是你要优化的值
  * 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。
* 对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。
* 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
* 最长公共子串
* 在动态规划中，你要将某个指标最大化。
* 费曼算法
  * 将问题写下来。
  * 好好思考。
  * 将答案写下来。

* 编辑距离算法
* 如何实现断字功能的应用程序
* 动态规划
  * 需要在给定约束条件下优化某种指标时，动态规划很有用。
  * 问题可分解为离散子问题时，可使用动态规划来解决。(子问题之间不要存在依赖关系)
  * 每种动态规划解决方案都涉及网格。（如何对问题进行建模并确定规划的策略）
  * 单元格中的值通常就是你要优化的值。
  * 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
  * 没有放之四海皆准的计算动态规划解决方案的公式。

---

* KNN算法虽然简单却很有用！要对东西进行分类时，可首先尝试这种算法。

  * 特征抽取（如何对现实问题进行建模，抽象出问题域中对象之间的数学表示）

  * 分类和回归
    * 分类就是编组
    * 回归就是预测结果（如一个数字）

* 推荐算法如何设置(创建推荐系统)

* **余弦相似度**

* 如何从问题域中对象上抽象出特征

  * 对象紧密相关的特征
  * 不偏不倚的特征
  * 在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。

* OCR（光学字符识别）

  * OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。

* 如何自动识别出这个数字是什么呢？可使用KNN。

  ​		1. 浏览大量的数字图像，将这些数字的特征提取出来。

  ​		2. 遇到新图像时，你提取该图像的特征，再找出它最近的邻居都是谁！

  * 朴素贝叶斯分类器
  * KNN算法
    * KNN用于分类和回归，需要考虑最近的邻居。
    * 分类就是编组。回归就是预测结果（如数字）。
    * 特征抽取意味着将物品转换为一系列可比较的数字。
    * 能否挑选合适的特征事关KNN算法的成败。

  ---

  * 数组中查找时，最快的方式是二分查找，但问题是每当有新用户注册时，都必须将其用户名插入该数组并重新排序，因为二分查找仅在数组有序时才管用。如果能将用户名插入到数组的正确位置就好了，这样就无需在插入后再排序。
  * 二叉查找树，对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。
    * 二叉查找树具有数据相同的查找效率，但删除和新增元素的却更高。
    * 数据具有空间大小的限制
    * 二叉查找树不支持随机访问， 二叉查找树需要保持平衡状态才具有较高的效率。
  * **Better Explained**

  * 并行算法
    * 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。
    * 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？

  * 分布式算法
  * 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。
    * 映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。
    * 归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。而归并是将一个数组转换为一个元素。

  

  