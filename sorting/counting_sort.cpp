//
// Created by 张锐 on 2020/12/16.
//

/*
 * 计数排序
 *
 * 决策树模型
 *  决策树的每一个叶节点代表一个最终输出
 *  决策树的每一个内部节点代表一次决策
 * 很多问题的求解往往需要多层次或多阶段的决策。当一个阶段决策完成后，可能有m种新的不同自然状态发生；每种自然状态下，都有m个新的策略可选择，选择后产生不同的结果并再次面临新的自然状态，
 * 继续产生一系列的决策过程，这种决策被称为序列决策或多级决策。问题的解通常由决策序列生成。
 *
 * 基于决策树模型的比较类排序算法的复杂度下界：
 *  n个元素的排列情况为 n！， 则排序问题的决策树中， 叶节点为 n!。 故树高最少为 lgn!; 求解复杂度下界为: O(nlgn);
 *
 * 计数排序先假设待排序序列各元素均在区间[0, k]上。
 * 在待排序序列中，如果我们能统计出有多少元素小于或等于某一个元素，我们也就知道了该元素的正确位置。
 *
 * 计数排序的实现办法：
 *  首先需要三个数组，第一个数组记录A要排序的数列大小为n，第二个数组B要记录比某个数小的其他数字的个数所以第二个数组的大小应当为K（数列中最大数的大小），第三个数组C为记录排序好了的数列的数组，
 *  大小应当为n。接着需要确定数组最大值并确定B数组的大小。并对每个数由小到大的记录数列中每个数的出现次数。因为是有小到大通过出现次数可以通过前面的所有数的出现次数来确定比这个数小的数的个数，
 *  从而确定其位置。对于重复的数，每排好一个数则对其位置数进行减减操作，以此对完成其余相同的数字进行排位。
 *
 * 伪代码实现
 *  countingSort(A, B, k): // 输入： A， 带排序序列， B：输出序列， k，输入序列中元素的最大值
 *      C[k];
 *      for i=0 to k:
 *          C[i] = 0;
 *      for i=0 to A.length:    // 计数：某个元素出现次数
 *          C[A[i]]++;
 *      for i=1 to k:
 *          C[A[i]+=C[A[i-1]];  // 累计计数：不大于当前元素的元素个数
 *      for i=A.length to 0:    // 将元素就位；（对于相等元素应当, 递减C[X], 使得后续的X放在秩更小的位置）  （从前至后，并递减C[X]， 可以保证排序算法的稳定性）
 *          B[C[A[i]]] = A[i];
 *          C[A[i]]--;
 * 复杂度：
 *  O(n+k);
 */

#include <cassert>

void countingSort(int A[], int B[], size_t size, unsigned int k) {
    k++;
    int C[k];
    for (int i = 0; i < k; ++i)
        C[i] = 0;
    for (int i = 0; i < size; ++i)
        C[A[i]]++;
    for (int i = 1; i < k; ++i)
        C[i]+=C[i-1];
    for (int i = size-1; i >= 0; --i) {
        B[C[A[i]]-1] = A[i];
        C[A[i]] = C[A[i]] -1;
    }
}