//
// Created by 张锐 on 2020/12/16.
//

/*
 * 归并排序迭代版
 * 算法分析
 *  归并排序算法的执行无非是对归并排序的迭代树进行后序遍历处理。
 *  内部节点的处理在子节点处理完成之后执行
 *      子节点各自有序后才会执行当前节点的 merge 算法。
 *
 * 算法思路: 考察非递归版本的后序遍历如何实现
 *  图/树的遍历依赖于：
 *      1. 选择策略：处于某个节点时，对后续的节点执行什么样子的选择
 *      2. 数据结构：需要借助一些数据结构来帮助确认当前的访问位置信息 (堆栈/颜色...)
 * 利用堆栈
 *  1. 从当前节点沿最左侧路径深入，直到最左侧节点： 对于每个节点，将当前节点入栈，若右子树存在，则将右子树节点入栈，若左子树存在，则将左子树节点入栈。
 *  2. 执行出栈，访问当前元素
 *      1. 出栈节点为跟节点，算法终止
 *      2. 出栈节点是否为左子节点
 *          a. Y：从步骤2开始执行
 *          b. N：从步骤1开始执行
 *
 * 设置节点的选择策略
 *  考察后序遍历情况下元素直接后继的选择情况
 *      1. 当前节点的右兄弟节点
 *      2. 当前节点的父节点
 *
 *  算法思路
 *      1. 从当前节点沿最左侧路径深入，直到最左侧节点
 *      2. 访问当前节点
 *      3. 将当前节点替换为其直接后继节点：若节点的后继节点为其父节点时，设置回溯标志位为true，为右侧兄弟节点时，设置回溯标志位为false；
 *          1. 若当前节点为null，算法终止
 *          2. 考察节点的回溯标志
 *              1. true: 从步骤2开始执行
 *              2. false: 从步骤1开始执行
 */

#include "merge.cpp"


template<typename T>
void mergeSortIter<T input[], size_t s) {
    size_t lo = 0, hi = s; bool backtrace = false;
    while(true) {
        size_t mid = (lo + hi) >> 1;
    }
}