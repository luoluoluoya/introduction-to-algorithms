//
// Created by 张锐 on 2020/12/9.
//

/**
插入排序：
    输入：给定的有限输入序列 A。序列A中元素支持`比较`操作
    输出：序列A的一个排列，{a1, a2, a3 ... an-1} 满足单调非减
基本策略：增量求解
算法思路：
    1。将A划分为两个子序列（位置标记实现）S，U。S中元素业已有序， U中元素无序。
    2。算法不断将U中首元素取出并插入S中适合的位置。
    3。U为空时算法终止。此时S中元素覆盖整个输入序列，输入序列业已有序。
伪码实现：
    for i=1 to n:
        x = A[i]
        for j=i-1 to 0:
            A[i] > x ? A[i+1] = A[i] : break;
        A[i] = x;
算法分析：
    算法在迭代过程中一只保持着一个循环不变式：A[0, i）中元素业以有序
    1。 迭代初始时：i=1, A[0, i) 中只含有一个元素，自然有序
    2。 迭代到第 k 步时， 若A[0,k)中元素有序， 则A[K]会插入至该有序部分并不破坏其有序性，故A[0, k]有序。 k+1次迭代时的循环不变式得以保持
    3。 迭代必定终止与 i = n； 此时循环不变式中维护的有序元素序列为 A[0, n-1), 整个输入序列业已有序
复杂度：\Theta(n^2)
空间占用：\Theta(1)
稳定性： 稳定
    待插入元素自后向前比较， 只有在真小于前一元素时才会发生交换
*/

template<typename T>
void insertionSort(T* input, size_t l) {
    for (int i = 1, j = 0; i < l; ++i, j = i-1) {   // 指针i界定有序和无序序列的分界点
        T x = input[i];
        while (j > -1 && input[j] > x) {            // 指针j指向不大于x的最后一个元素。 x应插入j之后
            input[j+1] = input[j];
            --j;
        }
        input[j+1] = x;
    }
}
